â³ interpret - a k interpreter for Go

Package interface (2 functions, no types):
  l := P("!3")  // Parse expr to ast (list []interface{})
  v := E(l, a)  // Evaluate to value (interface{})
  //k-tree: a map[interface{}]interface{}

Types
    complex128        numbers    1 -2.3 5e6 1i0 3a270
  []complex128        uniform vectors       1 2.3 -55
  []interface{}       list      (1;2;3;2`b;"x";(4;5))
  string              symbol/chars "x\nz" `a`str`list
  [2][]interface{}    dict                  [a:1;b:2]
  func                function            {x+y}  âŸ  +
Any Go var present in the k-tree can be used as well:
  any slice           list                 []mytype{}
  any map or struct   dict  (string keys for structs)
  any numeric type    number        type myint uint16
  any function can be called                 func(){}
  get methods with @  f:mytype@`m;f[3] or mytype`m[3]

    a     l     a-a   l-a   a-l   l-l 
+   flp   flp  [add] [add] [add] [add]  â‰
-  [neg] [neg] [sub] [sub] [sub] [sub]   
*   fst   fst  [mul] [mul] [mul] [mul]  Ã—
%  [inv] [inv] [div] [div] [div] [div]  Ã·
!   til   odo   mod    -    mod>  mkd   â³
&   wer   wer  [min] [min] [min] [min]  âŒŠ
|   rev   rev  [max] [max] [max] [max]  âŒ½âŒˆ
<   asc   asc  [les] [les] [les] [les]  â‹
>   dsc   dsc  [mor] [mor] [mor] [mor]  â’
=   eye   grp  [eql] [eql] [eql] [eql]  
~  [not] [not]  mch   mch   mch   mch   â‰¡
,   enl   enl   cat   cat   cat   cat   
^   is0  [is0]  ept   ept   ept   ept   
#   cnt   cnt   tak   rsh   tak   rsh   â´â†‘ 
_  [flr] [flr]  drp   drp   drp   cut   âŒŠâ†“
$   fmt  [fmt]  cst   cst   cst   cst   
?   rng   unq   rnd   fnd   rnd   fnd>  
@   typ   typ   atx   atx   atx   atx   
.   evl   evl   cal   cal   cal   cal   
/    -     -     -     -    pak   pak     
\    -     -     -    upk   spl   -      
                                                                     
    mv/nv dv    l-mv  l-dv        
'   ech   ecd   ecd   ecd   Â¨     
':   -    ecp    -    eci   â¨     infâˆ nanÃ¸ piÏ€
/:   -     -    ecr   ecr   âŒ¿     sqrâˆš logâŸ pow,expâ£
\:   -     -    ecl   ecl   â€     sin  cos  tan
/   fidx  ovr   whl   ovi         absâ€– angğœ‘ degÂ°
\   sfx   scn   swl   sci         reâ„œ  imâ„‘  con

   +m  â‰ flip, transpose    /  â‰3 2â´â³6           â†’ (0 2 4;1 3 5)
   -x  negate               / -(1;2;(3;(4;5)))   â†’ (-1;-2;(-3;(-4 -5)))
   *l  first                / *2 3 4             â†’ 2
   *d  first                / *[a:1;b:2]         â†’ 1
con[x] conjugate complex    / con 1i3            â†’ 1i-3
   âˆšx  sqrt[x] square root  / âˆš- 4 9             â†’ 0i-2 0i-3
   %x  Ã· inverse            / %2 5               â†’ 0.5 0.2
   â€–x  abs[x] magnitue      / â€–3.2a30            â†’ 3.2
   ğœ‘x  rad[x] phase         / ğœ‘-1                â†’ Ï€
   Â°x  deg[x] angle         / Â°1i1               â†’ 45
   â„œx  re[x] real part      / â„œ1a90              â†’ 0
   â„‘x  im[x] imag part      / â„‘1a90              â†’ 1
   !n  â³ til, iota          / â³3                 â†’ 0 1 2
   !d  keys                 / ![a:1;b:2]         â†’ (`a;`b)
   !l  â³ odometer           / â³3 2               â†’ (0 0 1 1 2 2;0 1 0 1 0 1)
   &l  where, repeat        / &3 0 4             â†’ 0 0 0 2 2 2 2
   |x  âŒ½ reverse            / âŒ½1 2 3             â†’ 3 2 1
   |d  âŒ½ reverse            / âŒ½[a:1;b:2]         â†’ [b:2;a:1]
   <x  â‹ grade up           / â‹8 2 9 1           â†’ 3 1 0 2
   >x  â’ grade down         / â’`alpha`beta       â†’ 1 0
   =n  unit matrix          / =3                 â†’ (1 0 0;0 1 0;0 0 1)
   =l  group                / =(3;"a";5;3;"a";3) â†’ (3;"a";5)!(0 3 5;1 4;,2)
   ~x  not                  / ~3 2 -1 0          â†’ 0 0 0 1
   ,x  enlist               / ,1                 â†’ ,1
   ^x  isnil isnan          / ^(0%0;0;Ã¸)         â†’ 1 0 1
   â£x  exp[x] exponential   / ğœ€>â€–1+â£0i1*Ï€        â†’ 1
   âŸx  log[x] logarithm     / âŸâ£1                â†’ 1
   #x  â´ count, length      / â´2 3â´â³6            â†’ 2
   _x  âŒŠ floor              / âŒŠ1.23              â†’ 1
   âŒˆx  ceil                 / âŒˆ1.23              â†’ 2
   $x  format, tostring     / $(1;2;3)           â†’ "(1;2;3)"
   ?n  random uniform       / +/1>?1000          â†’ 1000
   ?-n random normal        / 900 > +/1>?-1000   â†’ 1
   ?i  random binormal      / (+/â€–?0i1000)<1300  â†’ 1 / âˆšÏ€Ã·2
   ?s  parse                / ?"1+2"             â†’ ("+";1;2)
   ?x  unique               / ?2 3 3 0 4 0       â†’ 2 3 0 4
   @x  type of              / (@5)â‰¡@-1.2i5       â†’ 1
   .s  parse and eval       / ."1+2"             â†’ 3
   .l  evaluate             / .(+;1;2)           â†’ 3
  x+y  add                  / 1+2 3 4            â†’ 3 4 5
  x-y  substract            / 2 3 4-1            â†’ 1 2 3
  x*y  Ã— multiply           / 2 0i1 1a270*0i1    â†’ 0i2 -1 1
  x%x  Ã· divide             / 1Ã·2                â†’ 0.5
  x!y  modulo               / 2!5                â†’ 1
  x!l  modulo               / 2!!10              â†’ 0 1 0 1 0 1 0 1 0 1
 xl!l  make dictionary      / `a`b`c!(10;2 3;`f) â†’ [a:10;b:2 3;c:`f]
  x&y  âŒŠ min                / 1 2 3 4&4 3 2 1    â†’ 1 2 2 1
  x|y  âŒˆ max                / 1 2 3 4|4 3 2 1    â†’ 4 3 3 4
  x<y  less than            / 5<8 1 5            â†’ 1 0 0
  x>y  more than            / 5>8 1 5            â†’ 0 1 0
  x=y  equals               / 1 Ã¸ âˆ=(1a0;0%0;1%0)â†’ 1 1 1
  xâ€–y  rct parts to complex / 2â€–!4               â†’ 2 2i1 2i2 2i3
  xÂ°y  pol polar to complex / 1 2 3Â°0 90 180     â†’ 1 0i2 -3
  xğœ‘y  prd polar to complex / 1ğœ‘0 Ï€ -Ï€           â†’ 1 -1 -1
  xâ£y  power                / 2â£3                â†’ 8
  xâˆšy  nrt[x;y] nth root    / ğœ€>â€–2-3âˆš8           â†’ 1
  xâŸy  lgn[x;y] base n log  / ğœ€>â€–3-10âŸ1000       â†’ 1
  x~y  â‰¡ match, deep equal  / 1a90 2.0 3â‰¡0i1 2 3 â†’ 1
  x,y  catentate            / (1;2),3            â†’ (1;2;3)
  x^y  except               / (!10)^!7           â†’ 7 8 9
  a#d  â†‘ take               / 2â†‘[a:1;b:2;c:3]    â†’ [a:1;b:2]
  a#l  â†‘ take               / -2â†‘â³10             â†’ 8 9
  l#d  â´ select             / `a`c#[a:1;b:2;c:3] â†’ [a:1;c:3]
  l#y  â´ reshape            / 2 3â´â³6             â†’ (0 1 2;3 4 5)
  x_d  â†“ delete             / `a`b_[a:1;b:2;c:3] â†’ [c:3]
  x_y  â†“ drop               / (1_1 2;-1_!3;5_,1) â†’ (,2;0 1;0#,0)
 xl_yl cut                  / 3 5_!8             â†’ (3 4;5 6 7)
  x$y  convert to typeof    / (int@8)$128        â†’ (int@8)$-128
  d$y  format               / [t:1]$[a:,1;b:,3]  â†’ "a b\n---\n1 3"
  n?m  roll                 / 100>#?100?100      â†’ 1
 -n?m  deal                 / #?-10?10           â†’ 10
  n?l  random select        / 100>#?100?!100     â†’ 1
 -n?l  deal shuffled        / #?-100?!100        â†’ 100
 xl?y  find                 / 3 5?â³7             â†’ 2 2 2 0 2 1 2
  l@y  at, index            / 2 5 6@0 2          â†’ 2 6
  d@y  at, index            / [a:1;b:2;c:3]@`a`c â†’ 1 3
  f@y  monadic call         / {-x}@2 3           â†’ -2 -3
  l.y  depth list index     / (1;(2;(3;4))).1 1 0â†’ 3
  d.y  depth dict index     / [a:1;b:[c:2]].`b`c â†’ 2
  x.m  method               / (myf`F0)[]+0       â†’ 2
  x.y  call                 / {x+y}.(3;4 5)      â†’ 7 8
  x.y  curry                / ({x+y+z}.(1;;3)) 2 â†’ 6
  s/y  join                 / ";"/`alpha`beta    â†’ "alpha;beta"
  s\y  split                / ";"\"a;b;;c;d"     â†’ `a`b``c`d
  f'x  Â¨ each               / -:Â¨1 2             â†’ -1 -2
x g'y  Â¨ each pair          / 2 3*Â¨4 5           â†’ 8 15
  g':x â¨ each prior         / -â¨1 5 3            â†’ 1 4 -2
x g':y â¨ each prior initial / 7-â¨1 5 3           â†’ -6 4 -2
x g/:y âŒ¿ each right         / 1 2+âŒ¿3 4 5         â†’ (4 5;5 6;6 7)
x g\:  â€ each left          / 1 2+â€3 4 5         â†’ (4 5 6;5 6 7)
  g/y  over, reduce         / +/1 2 3            â†’ 6
  g\y  scan                 / +\1 2 3            â†’ 1 3 6
x g/y  over initial         / 5+/1 2 3           â†’ 11
x g\y  scan initial         / 5+\1 2 3           â†’ 6 8 11
n f/y  for, repeat          / 3 (2â£)/2           â†’ 65536
t f/y  while                / {x<100}{x*2}/1     â†’ 128
x f\y  scan for             / 2 âˆš:\81            â†’ 81 9 3
t f\y  scan while           / {x<100}(2*)\1      â†’ 1 2 4 8 16 32 64 128
  f/y  fixed point          / âˆš:/2               â†’ 1
  f\y  scan fixed           / -:\3               â†’ 3 -3
 Ï€Ã¸âˆğœ€  numeric constants    / (Ï€;Ã¸;âˆ;ğœ€)=Ï€ Ã¸ âˆ ğœ€  â†’ 1 1 1 1
   $[x;z;y;â€¦] if, switch    / $[1>2;âˆ;ğœ€]         â†’ 1e-14
  xâˆ‡y  tail call            / {$[x>100;x;âˆ‡x+1]}1 â†’ 101
