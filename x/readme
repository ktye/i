k's source as a k table (k.k)

t:+`n`t`p`i`s!(!#T;T;P;I;S) /node type parent i-value s-value

k k.k go.k -e 'x:`"k.go"<emit go``'       /generate k.go main
k k.k go.k -e 'x:`"k.go"<emit go`lib`k'   /generate k.go lib
k k.k wa.k -e         '`<emit wa``'       /generate wasm(text) (wip)
next: cc wb pa qb rv zi ha

a compiler backend implements a function per node type to transform the node into string form.
e.g. go[opts] sets the function dict F to use the Go code generating functions.


emit[opts] transforms the table to a string of program source code.
it folds the table in reverse order  f/[();|!#P;|n]
the first argument is a stack (of string results) and n is the child count per node:
 n:(&#P){x[y]+:1}/P; n[0]-:1
for each node, f cuts the number of children from the stack, calls the emitter based on the node's type
with arguments x:node id, and y the evaluated children in string form.
the result is catenated to the stack.

ast transformations are done on the table before calling emit.
the go backend does not need any transformations.


node type                    i-value             s-value
 prg     root node           -                   prog/libname    first node only
 mem     memory segment      #64k blocks         `a|`b           a|b: memory1|memory2
 con     constant            -                   name            child type lit
 var     variable            -                   name            child type lit
 lit     literal (con|var)   val(32bit)|C-index  type
 tab     func table entry    index               func name
 fun     function            func index          func name       children: args rets locs ast dfr
 arg     func argument       arg index           type            child type sym
 sym     symbol              -                   name
 res     return value        ret val index       type            unnamed
 loc     local var decl      loc index           type            child type sym
 ast     func ast root       -                   -               one per func
 stm     statement list      -                   -
 ret     return              -                   `|type          children: return values, s-type only for single res
 cal     function call       func node           func name       children: args
 cli     indirect call       #args               -               children: func-expr args arg-types ret-types
 drp     drop return vals    -                   -               child type cal
 get     get local           arg node            varname
 Get     get global          glo node            varname
 lod     load                -                   type(bijf)      child:    addr
 sto     store               -                   type(bijf)      children: addr, value
 asn     assignment          #symbols            modifier        children: syms typs expr(s) | syms typs expr
 cst     cast                -                   dst type        2 children: typ(src), arg
 typ     type                -                   type
 cnd     if condition        -                   `|type          2|3 children: if then [else]
 nop     ignore              -                   -
 jmp     break/continue      1(break)|0(cont)    label
 swc     switch              1(has default)      `|result-type   children: expr cases [default]
 for     loop                1(simple)           label           children: (cond|nop) (post|nop) body
 dfr     defer stmt node     -                   -               child type cal
unary operator nodes
 neg|not                     1                   type            1 child
binary operator nodes
 eql|les|mor|gte|lte|and|orr 2                   type            2 children
 add|sub|mul|div|mod|shr|shl	
 xor|neq|ant(andnot)|bnd|bor(&& ||)			     
 
types: `i`u`j`k`f`C`I`F!(i32;u32;i64;u64;f64;i8x16;i32x4;f64x2)
			     
the table is generated by github.com/ktye/wg/k.go
number of nodes:     #t             /35826
number of functions: #t{t=`fun}     /487
max depth:           |/dp P         /28


aaron's thesis:
3.2.4:table d(depth) t(primary class) k(sub class) n(name/reference)
3.2.6:I←{(⊂⍵)⌷⍺}
3.3:parent from depth
3.4:
 p:0 0 1 2 0 4 5 5 7 0 9 10 11 12 13 12 12 16 10 18 19 20 19 19 23 10 25
 p@&~3=t p            / (t[p]≠3)/p
 p p@&~3=t p          / p I (t[p]≠3)/p
 @[p;i;p p i:&~3=t p] / p I@{t[⍵]≠3} p    @(At) amends despite the name

